/*
 * This file is part of the Meteor Client distribution (https://github.com/MeteorDevelopment/meteor-client).
 * Copyright (c) Meteor Development.
 */

package meteordevelopment.meteorclient.systems.modules.exploits;

import io.netty.buffer.Unpooled;
import meteordevelopment.meteorclient.events.packets.PacketEvent;
import meteordevelopment.meteorclient.events.world.BlockUpdateEvent;
import meteordevelopment.meteorclient.settings.*;
import meteordevelopment.meteorclient.systems.modules.Categories;
import meteordevelopment.meteorclient.systems.modules.Module;
import meteordevelopment.meteorclient.utils.network.PacketUtils;
import meteordevelopment.meteorclient.utils.player.ChatUtils;
import meteordevelopment.orbit.EventHandler;
import meteordevelopment.orbit.EventPriority;
import net.minecraft.network.PacketByteBuf;
import net.minecraft.network.packet.Packet;
import net.minecraft.network.packet.s2c.play.BlockUpdateS2CPacket;
import net.minecraft.network.packet.s2c.play.ScreenHandlerSlotUpdateS2CPacket;
import net.minecraft.util.Formatting;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.spongepowered.include.com.google.common.collect.Lists;
import org.spongepowered.include.com.google.gson.*;

import javax.annotation.Nonnull;
import java.io.StringWriter;
import java.lang.instrument.Instrumentation;
import io.netty.buffer.ByteBuf;
import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.text.SimpleDateFormat;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Vector;
import joptsimple.internal.Strings;



import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.List;
import java.util.Set;

public class PacketLogger extends Module {

    private final SettingGroup sgGeneral = settings.getDefaultGroup();
    private final Setting<Set<Class<? extends Packet<?>>>> s2cPackets = sgGeneral.add(new PacketListSetting.Builder()
        .name("S2C-packets")
        .description("Server-to-client packets to log.")
        .filter(aClass -> PacketUtils.getS2CPackets().contains(aClass))
        .build()
    );

    private final Setting<Set<Class<? extends Packet<?>>>> c2sPackets = sgGeneral.add(new PacketListSetting.Builder()
        .name("C2S-packets")
        .description("Client-to-server packets to log.")
        .filter(aClass -> PacketUtils.getC2SPackets().contains(aClass))
        .build()
    );

    private final Setting<Boolean> logChat = sgGeneral.add(new BoolSetting.Builder()
        .name("log-chat")
        .description("Prints logged packets to chat")
        .defaultValue(true)
        .build()
    );
    private final Setting<Boolean> logStdout = sgGeneral.add(new BoolSetting.Builder()
        .name("log-stdout")
        .description("Prints logged packets to stdout")
        .defaultValue(true)
        .build()
    );
    private final Setting<Integer> threshold = sgGeneral.add(new IntSetting.Builder()
        .name("oversized-packet-threshold")
        .description("Threshold for oversized packet notifications, in bytes")
        .defaultValue(1048576)
        .min(1)
        .sliderRange(1, 2097152)
        .build()
    );


    public PacketLogger() {
        super(Categories.Exploits, "packet-logger", "Logs incoming/outgoing packets");

    }

    private int GetPacketSize(Packet<?> packet)
    {
        PacketByteBuf byteBuf = new PacketByteBuf(Unpooled.buffer());
        packet.write(byteBuf);
        //SHOULD work
        return byteBuf.writerIndex();


    }
    private void PrintLog(String s)
    {
        if(logStdout.get()) System.out.println(s);
        if(logChat.get()) info(s);
    }

    //If something broke, THIS is the part
    private String GetPacketData(Packet<?> packet)
    {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        //credits 2 https://github.com/ftbsc/thax-public/blob/613a04140aa332c858c85be74586b333bbae2682/src/main/java/com/matt/forgehax/mods/PacketLogger.java#L282

        return gson.toJson(objectToElement(packet, true, null, Lists.newArrayList()));
    }

    private String GetPacketInfo(Packet<?> packet, boolean includeData)
    {
        String res = "Packet: " + PacketUtils.getName((Class<? extends Packet<?>>) packet.getClass()) + ", Size = " + GetPacketSize(packet);
        if(includeData) res += GetPacketData(packet);

        return res;
    }



    private void NotifyLog(Packet<?> packet)
    {
        String notif = GetPacketInfo(packet, true);
        PrintLog(notif);

    }

    private void LogOversized(Packet<?> packet)
    {
        int packetSize = GetPacketSize(packet);
        if(packetSize >= threshold.get())
        {
            String notif = GetPacketInfo(packet, false);
            PrintLog(notif);
        }
    }



    @EventHandler(priority = EventPriority.HIGHEST + 1)
    private void onReceivePacket(PacketEvent.Receive event) {
        LogOversized(event.packet);
        if (s2cPackets.get().contains(event.packet.getClass()))
        {
            NotifyLog(event.packet);
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST + 1)
    private void onSendPacket(PacketEvent.Send event) {
        LogOversized(event.packet);
        if (c2sPackets.get().contains(event.packet.getClass())) NotifyLog(event.packet);
    }
    //I have 0 clue what this does but thanks anyway
    //https://github.com/ftbsc/thax-public/blob/613a04140aa332c858c85be74586b333bbae2682/src/main/java/com/matt/forgehax/mods/PacketLogger.java#L291
    private static JsonElement objectToElement(
        Object obj,
        boolean deep,
        @Nullable Class<?> superClassLimit,
        @NotNull final List<Object> dejaVu) {
        JsonObject json = new JsonObject();
        dejaVu.add(obj);
        if (obj != null) {
            Class<?> clazz = obj.getClass();
            do {
                try {
                    for (Field field : clazz.getDeclaredFields()) {
                        try {
                            if (!Modifier.isStatic(field.getModifiers())) {
                                field.setAccessible(true);
                                Object value = null;
                                String name;
                                try {
                                    value = field.get(obj);
                                    name =
                                        clazz.getSimpleName()
                                            + "."
                                            + field.getName()
                                            + "@"
                                            + Integer.toHexString(Objects.hashCode(value));
                                } catch (Throwable t) {
                                    name = "null@0";
                                }
                                /*
                                if (dejaVu.contains(value)) {
                                    json.add(name, Objects.toString(value));
                                } else {
                                    json.add(name, objectAsJson(value, dejaVu));
                                }
                                */
                                //json.add(name, new JsonObject(1));
                                json.add(name, objectAsJson(value, dejaVu));
                            }
                        } catch (Throwable t) {
                        }
                    }
                } catch (Throwable t) {
                } finally {
                    if (!deep || (superClassLimit != null && clazz.equals(superClassLimit))) {
                        clazz = null;
                    } else {
                        clazz = clazz.getSuperclass();
                    }
                }
            } while (clazz != null && !Object.class.equals(clazz));
        }
        return json;
    }
    private static JsonElement objectAsJson(Object obj, @Nonnull final List<Object> dejaVu) {
        if (obj == null) {
            return new JsonPrimitive("null");
        }
        try {
            if (obj.getClass().isPrimitive() || obj instanceof String) {
                return new JsonPrimitive(obj.toString());
            }
            if (obj.getClass().isArray()) {
                JsonArray array = new JsonArray();
                for (Object child : (Object[]) obj) {
                    array.add(objectAsJson(child, dejaVu));
                }
                return array;
            } else if (obj instanceof Collection) {
                JsonArray array = new JsonArray();
                for (Object child : (Collection) obj) {
                    array.add(objectAsJson(child, dejaVu));
                }
                return array;
            } else if (obj instanceof Map) {
                JsonObject json = new JsonObject();
                for (Map.Entry<Object, Object> entry : ((Map<Object, Object>) obj).entrySet()) {
                    json.add(entry.getKey().toString(), objectAsJson(entry.getValue(), dejaVu));
                }
                return json;
            } else if (obj instanceof ByteBuf) {
                return new JsonPrimitive(((ByteBuf) obj).toString(Charset.defaultCharset()));
                /* TODO: i have no idea how this works, ITextComponent is no longer a thing so im just gonna pray that it works w/o it
            } else if (obj instanceof ITextComponent) {
                return new JsonPrimitive(((ITextComponent) obj).getUnformattedText());
                */
            } else if (defaultToString(obj).equals(obj.toString())) { // not unique toString method
                // NOTE: make sure this is the last if statement
                return objectToElement(obj, true, null, dejaVu);
            }
        } catch (Throwable t) {
        }
        return new JsonPrimitive(obj.toString());
    }

    private static String defaultToString(Object o) {
        try {
            return o.getClass().getName() + "@" + Integer.toHexString(Objects.hashCode(o));
        } catch (Throwable t) {
            return "null@0";
        }
    }

    private static Collection<Class<?>> getLoadedClasses(ClassLoader loader) {
        try {
            Objects.requireNonNull(loader);
            Class<?> mclass = loader.getClass();
            while (mclass != ClassLoader.class) {
                mclass = mclass.getSuperclass();
            }
            Field classes = mclass.getDeclaredField("classes");
            classes.setAccessible(true);
            return (Vector<Class<?>>) classes.get(loader);
        } catch (Throwable t) {
            return Collections.emptyList();
        }
    }

}
