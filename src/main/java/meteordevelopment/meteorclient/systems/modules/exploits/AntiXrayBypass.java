/*
 * This file is part of the Meteor Client distribution (https://github.com/MeteorDevelopment/meteor-client).
 * Copyright (c) Meteor Development.
 */

package meteordevelopment.meteorclient.systems.modules.exploits;

import meteordevelopment.meteorclient.events.world.TickEvent;
import meteordevelopment.meteorclient.settings.*;
import meteordevelopment.meteorclient.systems.modules.Categories;
import meteordevelopment.meteorclient.systems.modules.Module;
import meteordevelopment.meteorclient.systems.modules.combat.Burrow;
import meteordevelopment.meteorclient.utils.player.FindItemResult;
import meteordevelopment.meteorclient.utils.player.InvUtils;
import meteordevelopment.orbit.EventHandler;
import net.fabricmc.loader.impl.lib.sat4j.core.Vec;
import net.minecraft.block.Block;
import net.minecraft.block.Blocks;
import net.minecraft.item.Items;
import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.math.Vec3i;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Queue;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class AntiXrayBypass extends Module {
    private final SettingGroup sgGeneral = settings.getDefaultGroup();
    private final Setting<Integer> distance = sgGeneral.add(new IntSetting.Builder()
        .name("check-distance")
        .description("Distance to check for blocks")
        .defaultValue(3)
        .sliderRange(1, 6)
        .build()
    );
    private final Setting<Integer> packetsPerSecond = sgGeneral.add(new IntSetting.Builder()
        .name("packets-per-second")
        .description("Packets sent per second")
        .defaultValue(1)
        .sliderRange(1, 40)
        .build()
    );
    private final Setting<Boolean> pauseOnMine = sgGeneral.add(new BoolSetting.Builder()
        .name("ascii-only")
        .description("Pause when mining")
        .defaultValue(false)
        .build()
    );

    public AntiXrayBypass() {
        super(Categories.Exploits, "anti-xray-bypass", "Bypasses Anti X-Ray plugins, use with xray module");
    }
    private int packetsSent = 0;
    private long lastCheckTime = System.currentTimeMillis();
    private LinkedHashSet<Vec3i> checkQueue = new LinkedHashSet<>();
    private HashSet<Vec3i> checkedBlocks = new HashSet<>();

    private boolean canReachBlock(Vec3i pos)
    {
        Vec3d eyePosDouble = mc.player.getEyePos();
        //man i fuckin hate this
        Vec3i playerEyePos = new Vec3i((int) Math.round(eyePosDouble.x), (int) Math.round(eyePosDouble.y), (int) Math.round(eyePosDouble.z));
        Vec3i delta = pos.subtract(playerEyePos);

        if(Math.abs(delta.getX()) > distance.get() || Math.abs(delta.getX()) > distance.get() || Math.abs(delta.getX()) > distance.get())
            return false;
        return true;
    }

    private void checkBlock(Vec3i pos)
    {


        if(!canReachBlock(pos))
            return;
        packetsSent++;
        checkedBlocks.add(pos);
        mc.player.networkHandler.sendPacket(new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.START_DESTROY_BLOCK, new BlockPos(pos), Direction.UP));
    }

    private Vec3i popFromQueue()
    {
        Iterator<Vec3i> it = checkQueue.iterator();
        Vec3i res = it.next();
        it.remove();
        return res;
    }

    private boolean shouldCheckBlock(BlockPos pos)
    {

        //anti xray on 2b only hides these blocks
        Block block = mc.world.getBlockState(pos).getBlock();
        if(block == Blocks.NETHERRACK)
            return true;
        if(block == Blocks.STONE)
            return true;
        if(block == Blocks.DEEPSLATE)
            return true;
        return false;
    }

    private void addBlockWithChecks(Vec3i pos)
    {

        BlockPos blockPos = new BlockPos(pos);

        if(!shouldCheckBlock(blockPos))
        {
            //add it and call it a day
            checkedBlocks.add(pos);
            return;
        }


        //double checks ik but shortens the queue
        //if(!isBlockWithinReach(pos))
        //    return;
        checkQueue.add(pos);
    }
    private void addBlocksToCheck()
    {
        //yeah yeah its pasted
        //courtesy 2 https://github.com/Pan4ur/ThunderHack-Recode/blob/main/src/main/java/thunder/hack/modules/render/XRay.java
        // ^fuck this client tho
        Vec3d eyePosDouble = mc.player.getEyePos();
        //man i fuckin hate this

        Vec3i playerEyePos = new Vec3i((int) Math.round(eyePosDouble.x), (int) Math.round(eyePosDouble.y), (int) Math.round(eyePosDouble.z));
        int range = distance.get();
        //im lazy ok
        for(int x = playerEyePos.getX() - range; x < playerEyePos.getX() + range; x++)
            for(int y = playerEyePos.getY() - range; y < playerEyePos.getY() + range; y++)
                for(int z = playerEyePos.getZ() - range; z < playerEyePos.getZ() + range; z++)
                    addBlockWithChecks(new Vec3i(x,y,z));

    }
    @Override
    public void onActivate()
    {
        checkQueue = new LinkedHashSet<>();
        checkedBlocks = new HashSet<>();
    }
    @EventHandler
    private void onTick(TickEvent.Post event) {
        //add ur shit here
        addBlocksToCheck();
        if(mc.interactionManager.isBreakingBlock())
            return;


        while((System.currentTimeMillis() - lastCheckTime < 1000) && !checkQueue.isEmpty() && (packetsSent <= packetsPerSecond.get()))
            checkBlock(popFromQueue());

        //reset only if 1s passes
        if(System.currentTimeMillis() - lastCheckTime >= 1000)
        {
            lastCheckTime = System.currentTimeMillis();
            packetsSent = 0;
        }

    }
}
